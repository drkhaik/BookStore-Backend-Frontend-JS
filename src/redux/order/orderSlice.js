import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { message } from 'antd';

// cart: [
//  {
//  quantity: 4, _id: "asd1224", detail: "", 
// },
//  {
//  quantity: 3, _id: "asd113", detail: "", 
// },
// ]
const initialState = {
  cart: []
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

export const orderSlice = createSlice({
  name: 'order',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addToCart: (state, action) => {
      let carts = state.cart;
      const item = action.payload;
      // console.log("check type", action.payload.type)
      // console.log("check item", item)
      // console.log("check carts", Array.isArray(carts));
      let isExistIndex = carts.findIndex(c => c._id === item._id)
      if (isExistIndex > -1) {
        if (item.type === 'add') {
          carts[isExistIndex].quantity = +(carts[isExistIndex].quantity) + +(item.quantity);
          carts[isExistIndex].total = +(carts[isExistIndex].total) + +(item.total);
          if (carts[isExistIndex].quantity > carts[isExistIndex].detail.quantity) {
            carts[isExistIndex].quantity = carts[isExistIndex].detail.quantity;
            carts[isExistIndex].total = carts[isExistIndex].detail.quantity * carts[isExistIndex].detail.price;
          }
        }
        if (item.type === 'change') {
          carts[isExistIndex].quantity = +item.quantity;
          carts[isExistIndex].total = +item.total;
          if (carts[isExistIndex].quantity > carts[isExistIndex].detail.quantity) {
            carts[isExistIndex].quantity = carts[isExistIndex].detail.quantity;
            carts[isExistIndex].total = carts[isExistIndex].detail.quantity * carts[isExistIndex].detail.price;
          }
        }
      } else {
        carts.unshift(item);
      }
      // update state
      state.cart = carts;
    },

    deleteItemInCart: (state, action) => {
      // console.log("check action", action.payload);
      let carts = state.cart.filter(c => c._id !== action.payload._id);
      // console.log("check carts", carts)
      state.cart = carts;
    },

    bulkDeleteItemInCart: (state, action) => {
      // payload= ['64bea8ffcc9aaf12db543b7c', '64cb41ccb27525506a7f207b']
      let carts = state.cart;
      let dataId = action.payload;
      for (let i = 0; i < dataId.length; i++) {
        const id = dataId[i];
        carts = carts.filter(c => c._id !== id);
      }
      state.cart = carts;
    },

  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
  },
});

export const { addToCart, deleteItemInCart, bulkDeleteItemInCart, } = orderSlice.actions;

export default orderSlice.reducer;
